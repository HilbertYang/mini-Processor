000	e3a01000	MOV R1, #0	R1=0（通常当数组 base 指针）
008	e3a00000	MOV R0, #0	R0=0（当常量 0 用）
010	e3a07000	MOV R7, #0	R7=0（后面 SLL 用作 shift 量）
018	e3a02000	MOV R2, #0	R2=0（外层 i = 0）
020	e3a0a00a	MOV R10, #10	R10=10（N=10，数组长度）
028	e162b00a	SLT R11, R2, R10	R11 = (i < N)?1:0
030	e8b00087	BEQ R11, R0, 135	若 R11==0（i>=N）跳到“结束区”
035	e2823000	ADD R3, R2, #0	R3 = i（内层 j 从 i 开始）
03d	e2833001	ADD R3, R3, #1	j = i+1
045	e163b00a	SLT R11, R3, R10	R11 = (j < N)?1:0
04d	e8b0005d	BEQ R11, R0, 93	若 j>=N 跳到外层 i++
052	e0c28007	SLL R8, R2, R7	R8 = i << R7（这里 R7=0，所以 R8=i）
05a	e0818008	ADD R8, R1, R8	R8 = base + i（a[i] 地址）
062	e0c39007	SLL R9, R3, R7	R9 = j << R7（同理 R9=j）
06a	e0819009	ADD R9, R1, R9	R9 = base + j（a[j] 地址）
072	e5985000	LDR R5, [R8, +#0]	R5 = a[i]
07a	e5996000	LDR R6, [R9, +#0]	R6 = a[j]
082	e1664005	SLT R4, R6, R5	R4 = (a[j] < a[i])?1:0
08a	e8400013	BEQ R4, R0, 19	若不需要交换（R4==0）跳过 swap
08f	e5895000	STR R5, [R9, +#0]	a[j] = old a[i]
097	e5886000	STR R6, [R8, +#0]	a[i] = old a[j]（完成交换）
09f	e2833001	ADD R3, R3, #1	j++
0a7	eaffff9c	B -100	回跳到内层循环条件检查（addr 045）
0ac	e2822001	ADD R2, R2, #1	i++
0b4	eaffff6a	B -150	回跳到外层循环条件检查（addr 028）
0ba	ea000003	B 3	跳到末尾（相当于结束/停住）