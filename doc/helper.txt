Data-processing (op=00):
    ADD Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 0100(ADD) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1000 0000 0000 0000 0000 0000

    Operand2 is Rm  :   1110 00 0(use reg) 0100(ADD) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1000 0000 0000 0000 0000 0000

    SUB Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 0010(SUB) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 0010 0000 0000 0000 0000 0000
    
    Operand2 is Rm  :   1110 00 0(use reg) 0010(SUB) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 0010 0000 0000 0000 0000 0000

    AND Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 0000(AND) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 0000 0000 0000 0000 0000 0000
    
    Operand2 is Rm  :   1110 00 0(use reg) 0000(AND) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 0000 0000 0000 0000 0000 0000

    ORR Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 1100(ORR) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1100 0000 0000 0000 0000 0000

    Operand2 is Rm  :   1110 00 0(use reg) 1100(ORR) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1100 0000 0000 0000 0000 0000
    
    MOV Rd, Operand2(Rn=0 + Operand2)
    Operand2 is imm8:   1110 00 1(use imm) 1101(MOV) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1101 0000 0000 0000 0000 0000
    
    Operand2 is Rm  :   1110 00 0(use reg) 1101(MOV) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1101 0000 0000 0000 0000 0000


    EOR Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 0001(EOR) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 0001 0000 0000 0000 0000 0000

    Operand2 is Rm  :   1110 00 0(use reg) 0001(EOR) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 0001 0000 0000 0000 0000 0000

    CMP Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 1010(CMP) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1010 0000 0000 0000 0000 0000
    
    Operand2 is Rm  :   1110 00 0(use reg) 1010(CMP) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1010 0000 0000 0000 0000 0000
    TST Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 1000(TST) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1000 0000 0000 0000 0000 0000

    Operand2 is Rm  :   1110 00 0(use reg) 1000(TST) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1000 0000 0000 0000 0000 0000
//=============================================================
//=============================================================
//=============================================================

Load / Store (op=01):(imm-Even though here is 0, we still use offset to do calculation)
    LDR Rd, [Rn, #offset] (This is just LW in MIPS, here Rd is the destination register and Rn is the base register)
    Rd = Memory[ Rn + offset ]
    ADD offset:         1110 01 0(imm) 1(P=pre-index) 1(U=add offset) 0(B=word) 0(W=no writeback) 1(L=load) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000 0000 0000(imm12[11:0])
                        
                        1110 0101 1001 0000 0000 0000 0000 0000
    
    SUB offset:         1110 01 0(imm) 1(P=pre-index) 0(U=sub offset) 0(B=word) 0(W=no writeback) 1(L=load) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000 0000 0000(imm12[11:0])
                        
                        1110 0101 0001 0000 0000 0000 0000 0000

    STR Rd, [Rn, #offset]
    Memory[ Rn + offset ] = Rd
    ADD offset:         1110 01 0(imm) 1(P=pre-index) 1(U=add offset) 0(B=word) 0(W=no writeback) 0(L=store) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000 0000 0000(imm12[11:0])
                        
                        1110 0101 1000 0000 0000 0000 0000 0000
    
    SUB offset:         1110 01 0(imm) 1(P=pre-index) 0(U=sub offset) 0(B=word) 0(W=no writeback) 0(L=store) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000 0000 0000(imm12[11:0])

                        1110 0101 0000 0000 0000 0000 0000 0000
//=============================================================
//=============================================================
//=============================================================
Branch (op=10):
    branch_target = pc + 9'd2 + if_off24[8:0];
    B label
                        1110 1010(B) 0000 0000 0000 0000 0000 0000  (offset is calculated by assembler)
    BL label
                        1110 1011(BL) 0000 0000 0000 0000 0000 0000  (offset is calculated by assembler)
//=============================================================
//=============================================================
//=============================================================
BX Rm (branch-and-exchange, op=00):
    BX Rm
                        1110 0001 0010 1111 1111 1111 0001 0000(Rm[3:0])
//=============================================================
//=============================================================
//=============================================================
NOP (No Operation):
    NOP:  32'hE000_0000  (AND R0,R0,R0 with result discarded)



New instruction But not align with the previous instruction,
!!! FOR Yukun!!!!!
This may be modify later
!!!!!!!!!!!!!!!!!!
//=============================================================
//  SLL  Rd,Rn,Rm        Shift Left  by Rm[5:0]
//    {4'hE, 3'b000, 4'b0110, 1'b0, Rn, Rd, 8'h00, Rm}
//    (I=0 selects variable-shift; I=1 preserves old shift-by-1 behaviour)
//
//  SRL  Rd,Rn,Rm        Shift Right by Rm[5:0]
//    {4'hE, 3'b000, 4'b0111, 1'b0, Rn, Rd, 8'h00, Rm}
//
//  JR   Rm              Jump Register (identical to BX Rm)
//    {4'hE, 24'h12FFF1, Rm[3:0]}


    branch_target = j_target[8:0];

//  J    target9         Unconditional absolute jump to 9-bit word address
//    inst[31:26] = 6'b111010  (op=2'b11 sub=2'b10)
//    inst[25:0]  = zero-padded target; lower 9 bits used as new PC
//    {6'b111010, 17'b0, target9[8:0]}
//
//  SLT  Rd,Rn,Rm        Set Less Than (signed): Rd = (Rn < Rm) ? 1 : 0
//    {4'hE, 3'b000, 4'b1011, 1'b0, Rn, Rd, 8'h00, Rm}
//



    branch_target  = pc + 9'd2 + beq_offset[8:0];

//  BEQ  Rn,Rm,off16     Branch if Equal (Rn == Rm)
//    inst[31:28]=4'hE  inst[27:24]=4'b1000
//    inst[23:20]=Rn  inst[19:16]=Rm  inst[15:0]=off16
//    branch_target = ifid_pc + 2 + sign_extend(off16)
//    {4'hE, 4'b1000, Rn, Rm, 16'(off16)}
//
//  BNE  Rn,Rm,off16     Branch if Not Equal (Rn != Rm)
//    inst[27:24]=4'b1001
//    {4'hE, 4'b1001, Rn, Rm, 16'(off16)}




//  [31:28]  cond   – 1110 (always; condition codes not evaluated)
//  [27:26]  op     – 00=data-proc, 01=load/store, 10=branch
//
//  Data-processing (op=00):
//    [25]   I      – 1=operand2 is 8-bit immediate, 0=register
//    [24:21] opcode – 0100 ADD, 0010 SUB, 0000 AND, 1100 ORR
//                     1101 MOV, 0001 EOR, 1010 CMP(no WB), 1000 TST(no WB)
//    [20]   S      – set flags (not used)
//    [19:16] Rn    – first source register
//    [15:12] Rd    – destination register
//    [11:8]  rot   – rotation amount (ignored; imm treated as zero-extended)
//    [7:0]   imm8  – 8-bit immediate (when I=1)
//    [3:0]   Rm    – second source register (when I=0)
//
//  Load / Store (op=01):
//    [25]   0      – immediate offset
//    [24]   P=1    – pre-index
//    [23]   U      – 1=add offset, 0=subtract
//    [22]   B=0    – word
//    [21]   W=0    – no writeback
//    [20]   L      – 1=LDR, 0=STR
//    [19:16] Rn   – base register
//    [15:12] Rd   – dest (LDR) / source (STR)
//    [11:0]  imm12 – unsigned byte offset
//
//  Branch (op=10):
//    [27:24] 1010  – B,  1011 = BL
//    [23:0]  signed offset (from instruction word address; pipeline adds 2)
//
//  BX Rm (branch-and-exchange, op=00):
//    [27:4]  24'h12FFF1, [3:0] Rm
//
//  NOP:  32'hE000_0000  (AND R0,R0,R0 with result discarded)
