Data-processing (op=00):
    ADD Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 0100(ADD) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1000 0000 0000 0000 0000 0000

    Operand2 is Rm  :   1110 00 0(use reg) 0100(ADD) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1000 0000 0000 0000 0000 0000

    SUB Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 0010(SUB) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 0010 0000 0000 0000 0000 0000
    
    Operand2 is Rm  :   1110 00 0(use reg) 0010(SUB) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 0010 0000 0000 0000 0000 0000

    AND Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 0000(AND) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 0000 0000 0000 0000 0000 0000
    
    Operand2 is Rm  :   1110 00 0(use reg) 0000(AND) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 0000 0000 0000 0000 0000 0000

    ORR Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 1100(ORR) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1100 0000 0000 0000 0000 0000

    Operand2 is Rm  :   1110 00 0(use reg) 1100(ORR) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1100 0000 0000 0000 0000 0000
    
    MOV Rd, Operand2(Rn=0 + Operand2)
    Operand2 is imm8:   1110 00 1(use imm) 1101(MOV) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1101 0000 0000 0000 0000 0000
    
    Operand2 is Rm  :   1110 00 0(use reg) 1101(MOV) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1101 0000 0000 0000 0000 0000


    EOR Rd, Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 0001(EOR) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 0001 0000 0000 0000 0000 0000

    Operand2 is Rm  :   1110 00 0(use reg) 0001(EOR) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 0001 0000 0000 0000 0000 0000

    CMP Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 1010(CMP) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1010 0000 0000 0000 0000 0000
    
    Operand2 is Rm  :   1110 00 0(use reg) 1010(CMP) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1010 0000 0000 0000 0000 0000
    TST Rn, Operand2
    Operand2 is imm8:   1110 00 1(use imm) 1000(TST) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 00000000(imm8)

                        1110 0010 1000 0000 0000 0000 0000 0000

    Operand2 is Rm  :   1110 00 0(use reg) 1000(TST) 0(S - no use here) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000(rot[11:8]) 0000(no use) 0000(Rm[3:0])

                        1110 0000 1000 0000 0000 0000 0000 0000
//=============================================================
//=============================================================
//=============================================================

Load / Store (op=01):(imm-Even though here is 0, we still use offset to do calculation)
    LDR Rd, [Rn, #offset] (This is just LW in MIPS, here Rd is the destination register and Rn is the base register)
    ADD offset:         1110 01 0(imm) 1(P=pre-index) 1(U=add offset) 0(B=word) 0(W=no writeback) 1(L=load) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000 0000 0000(imm12[11:0])
                        
                        1110 0101 1001 0000 0000 0000 0000 0000
    
    SUB offset:         1110 01 0(imm) 1(P=pre-index) 0(U=sub offset) 0(B=word) 0(W=no writeback) 1(L=load) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000 0000 0000(imm12[11:0])
                        
                        1110 0101 0001 0000 0000 0000 0000 0000

    STR Rd, [Rn, #offset]
    ADD offset:         1110 01 0(imm) 1(P=pre-index) 1(U=add offset) 0(B=word) 0(W=no writeback) 0(L=store) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000 0000 0000(imm12[11:0])
                        
                        1110 0101 1000 0000 0000 0000 0000 0000
    
    SUB offset:         1110 01 0(imm) 1(P=pre-index) 0(U=sub offset) 0(B=word) 0(W=no writeback) 0(L=store) 0000(Rn[19:16]) 0000(Rd[15:12]) 0000 0000 0000(imm12[11:0])

                        1110 0101 0000 0000 0000 0000 0000 0000
//=============================================================
//=============================================================
//=============================================================
Branch (op=10):
    B label
                        1110 1010(B) 0000 0000 0000 0000 0000 0000  (offset is calculated by assembler)
    BL label
                        1110 1011(BL) 0000 0000 0000 0000 0000 0000  (offset is calculated by assembler)
//=============================================================
//=============================================================
//=============================================================
BX Rm (branch-and-exchange, op=00):
    BX Rm
                        1110 0001 0010 1111 1111 1111 0001 0000(Rm[3:0])
//=============================================================
//=============================================================
//=============================================================
NOP (No Operation):
    NOP:  32'hE000_0000  (AND R0,R0,R0 with result discarded)
















//  [31:28]  cond   – 1110 (always; condition codes not evaluated)
//  [27:26]  op     – 00=data-proc, 01=load/store, 10=branch
//
//  Data-processing (op=00):
//    [25]   I      – 1=operand2 is 8-bit immediate, 0=register
//    [24:21] opcode – 0100 ADD, 0010 SUB, 0000 AND, 1100 ORR
//                     1101 MOV, 0001 EOR, 1010 CMP(no WB), 1000 TST(no WB)
//    [20]   S      – set flags (not used)
//    [19:16] Rn    – first source register
//    [15:12] Rd    – destination register
//    [11:8]  rot   – rotation amount (ignored; imm treated as zero-extended)
//    [7:0]   imm8  – 8-bit immediate (when I=1)
//    [3:0]   Rm    – second source register (when I=0)
//
//  Load / Store (op=01):
//    [25]   0      – immediate offset
//    [24]   P=1    – pre-index
//    [23]   U      – 1=add offset, 0=subtract
//    [22]   B=0    – word
//    [21]   W=0    – no writeback
//    [20]   L      – 1=LDR, 0=STR
//    [19:16] Rn   – base register
//    [15:12] Rd   – dest (LDR) / source (STR)
//    [11:0]  imm12 – unsigned byte offset
//
//  Branch (op=10):
//    [27:24] 1010  – B,  1011 = BL
//    [23:0]  signed offset (from instruction word address; pipeline adds 2)
//
//  BX Rm (branch-and-exchange, op=00):
//    [27:4]  24'h12FFF1, [3:0] Rm
//
//  NOP:  32'hE000_0000  (AND R0,R0,R0 with result discarded)
